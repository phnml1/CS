# 프로그래밍 패러다임
## 선언형과 명령형
프로그래머에게 관점을 갖게 해주는 역할을 하는 개발 방법론이며,
크게 선언형, 명령형으로 나눈다.

명령형은 **어떻게**를 일일히 간섭, 선언형은 **무엇**에 집중하고 나머지는 맡긴다.


## 선언형과 함수형 프로그래밍
`선언형 프로그래밍`이란 '무엇을' 풀어내는가에 집중하는 패러다임이며, `프로그램은 함수로 이루어진 것이다.` 라는 명제가 담겨 있는 패러다임이기도 하다.

`함수형 프로그래밍`은 선언형 패러다임의 일종이다.

예를 들어, 자연수로 이루어진 배열에서 최댓값을 찾으라고 한다면 다음과 같이 로직을 구성한다.

```js
const list = [1, 2, 3, 4, 5, 11, 12]
const ret = list.reduce((max, num) => num > max ? num : max, 0)
console.log(ret) // 12 
```
앞의 코드는 배열만 받아서 누적한 결과 값을 반환하는 `순수 함수` 이다.

`함수형 프로그래밍`은 이와 같은 `순수 함수`들을 블록처럼 쌓아 로직을 구현하고, `고차 함수`를 통해 **재사용성**을 높인 프로그래밍 패러다임이다. 

자바스크립트는 함수가 **일급 객체**이기 때문에 `객체지향 프로그래밍`보다는 `함수형 프로그래밍` 방식이 선호된다.
### 부수 효과
부수효과란 다음과 같은 변화가 발생하는 작업이다.
-   변수의 값이 변경됨
-   자료 구조를 제자리에서 수정함
-   객체의 필드값을 설정함
-   예외나 오류가 발생하며 실행이 중단됨
-   콘솔 또는 파일 I/O가 발생함

### 순수 함수
이러한 부수 효과(Side Effect)들을 제거한 함수들을 순수 함수(Pure Function)이라고 부르며, 출력이 입력에만 의존하는 것을 의미한다.

```js
const pure= (a,b) => {
	return a+b;
} 
```
pure는 들어오는 매개변수 a, b에만 영향을 받는다. 만약 a,b말고 c 등이 출력에 영향을 준다면 순수함수 x

### 고차 함수
고차 함수란 함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것이다.

이때 고차 함수를 쓰기 위해서는 해당 언어가 **일급 객체**라는 특징을 지녀야 한다
- 변수나 메서드에 함수를 할당 가능
-  함수안에 함수를 매개변수로 사용 가능
-  함수가 함수를 반환 가능

이외에도 함수형 프로그래밍은 커링, 불변성 등 많은 특징을 가지고 있다.

## 객체 지향 프로그래밍이란?
`객체 지향 프로그래밍`(OOP, Object-Oriented Programming)은 객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식을 말한다.
 - 코드의 변경을 최소화하고, 유지보수를 하는데 유리 하다.
 - 코드의 재사용을 통해 반복적인 코드를 최소화하고, 코드를 최대한 간결하게 표현가능
- 설계에 많은 시간이 소요되며 처리 속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느리다.

예를 들어, 자연수로 이루어진 배열에서 최댓값을 찾으라고 한다면 다음과 같이 로직을 구성한다.
```js
const ret = [1, 2, 3, 4, 5, 11, 12]
class List {
    constructor(list) {
        this.list = list
        this.mx = list.reduce((max, num) => num > max ? num : max, 0)
    }
    getMax() {
        return this.mx
    }
}
const a = new List(ret)
console.log(a.getMax()) // 12
```

## 객체지향 프로그래밍의 특징
### 추상화
추상화란 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것이다.

예를 들어, `자동차(Car)`와  `오토바이(MotorBike)`는 모두  `이동 수단`이며 모든 이동 수단은  **전진과 후진을 할 수 있다는 공통점**을 가진다.  

이를 위해 Vehicle이라는 인터페이를 만들어 **어떤 객체가 수행해야 하는 핵심적인 역할만을 규정하고, 실제적인 구현은 해당 인터페이스를 구현하는 각각의 객체들에서 하도록** 프로그램을 설계하는 것을 의미한다.

```java
public interface Vehivle {
	public abstract void start()
	void moveForward();
	void moveBackward();
}

public class Car implements Vehicle {
public void moveForward(){...}
public void moveBackward(){...}
}

public class MotorBike implements Vehicle {
public void moveForward(){...}
public void moveBackward(){...}
}
```
### 상속
상속성은 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것을 의미한다. 코드의 재사용 측면, 계층적인 관계 생성, 유지보수 측면에서 중요하다.

### 캡슐화
캡슐화는 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감춰 은닉하는 것을 말한다. 

### 다형성
다형성은 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것을 말한다. 대표적으로 오버로딩, 오버라이딩이 있다.

**오버로딩**

같은 이름을 가진 메서드를 여러 개 두는 것을 말한다. 메서드의 타입, 매개변수의 유형, 개수 등으로 여러 개를 둘 수 있으며, 컴파일 중에 발생하는 '정적' 다형성 이다.
```java
class Person {

    public void eat(String a) {
        System.out.println("I eat " + a);
    }

    public void eat(String a, String b) {
        System.out.println("I eat " + a + " and " + b);
    }
}

public class CalculateArea {

    public static void main(String[] args) {
        Person a = new Person();
        a.eat("apple");
        a.eat("tomato", "phodo");
    }
}
/*
I eat apple
I eat tomato and phodo
*/
```

**오버라이딩**

오버라이딩은 주로 메서드 오버라이딩을 말하며 상위 클래스로부터 상속받은 메서드를 하위클래스가 재정의하는 것을 의미한다.
런타임중에 발생하는 '동적' 다형성이다.
```js
class Animal {
    public void bark() {
        System.out.println("mumu! mumu!");
    }
}

class Dog extends Animal {
    @Override
    public void bark() {
        System.out.println("wal!!! wal!!!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.bark();
    }
}
/*
wal!!! wal!!!
*/
```
앞의 코드에서 부모 클래스는 mumu!로 짖게 만들었지만 자식 클래스에서 wa!! wa!!!로 짖게 만들었더니 자식 클래스 기반으로 메서드가 재정의됨을 알 수 있다.

## 객체 지향 설계의 5원칙 S.O.L.I.D
### 단일 책임 원칙 (SRP - Single Responsibility Principle)
단일 책임 원칙은 **모든 클래스**는 **단 하나의 책임**만 가져야 한다는 원칙이다.
- 책임의 의미는 하나의 `기능 담당`이다.

- 하나의 클래스는 **하나의 기능을 담당하여 하나의 책임만 수행하는데 집중**되도록 클래스를 따로따로 설계하라는 원칙이다.
- 예를 들어 A를 고쳤더니 B를 수정해야하고 또 C를 수정해야하고, C를 수정했더니 다시 A로 돌아가서 수정해야 하는, 마치 책임이 순환되는 형태가 되어버린다.
따라서 SRP원칙을 따름으로써 한 책임의 변경으로부터 다른 책임의 변경으로의 연쇄 작용을 극복할 수 있게 된다.
- 프로그램의 유지보수성을 높일 수 있다.

### 개방 폐쇄 원칙 (OCP-Open Closed Principle)
`확장에 열려있어야 하며, 수정에는 닫혀 있어야 한다` 라는 뜻 이다. 

 즉, **유지 보수 사항이나 기능 추가 요청이 생기면 확장을 통해 이를 손쉽게 구현하면서, 수정은 최소화 하도록 프로그램을 작성하는 설계 기법**이다.

어렵게 생각할 필요없이,  **OCP 원칙**은 **추상화** **사용을 통한 관계 구축 (추상클래스와 상속 사용)을 권장**을 의미하는 것이다.

### 리스코프 치환 원칙 (LSP - Liskov Substitution Principle)

프로그램의 객체는 `프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다`는 것을 의미한다.

부모 객체에 자식 객체를 넣어도 시스템이  문제없이 돌아가게 만드는 것을 말한다.

- 쉽게 말하면 LSP는 **다형성 원리를 이용하기 위한 원칙** 개념으로 보면 된다.

- 자식 클래스로 부모 클래스의 내용을 상속하는데, 기존 코드에서 보장하던 조건을 수정하거나 적용시키지 않으면 안되고, **사전에 약속한 기획대로 구현하고, 상속 시 부모에서 구현한 원칙을 따라야 한다**가 이 원칙의 핵심이다.

### 인터페이스 분리 원칙 (ISP - Interface Segregation Principle)
ISP 원칙은 **인터페이스를 각각 사용에 맞게 끔 잘게 분리** 즉, 하나의 일반적인 인터페이스보다 구체적인 여러개의 인터페이스를 만들도록 해야한다는 설계 원칙이다.

 SRP 원칙이 **클래스의 단일 책임**을 강조한다면, ISP는 **인터페이스의 단일 책임**을 강조하는 것으로 보면 된다

### 의존 역전 원칙 (DIP, Dependency Inversion Principle)
DIP 원칙은 자신보다 변하기 쉬운 것에 의존 하던 것을 그 **대상의 클래스를 직접 참조하는 것이 아니라, 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조**하라는 원칙이다.

즉, 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는, 변화하기 어려운 것 거의 변화가 없는 것에 의존하라는 것이다.

## 절차형 프로그래밍
절차형 프로그래밍은 로직이 수행되어야 할 연속적인 계산 과정으로 이루어져 있다. 

일이 진행되는 방식으로 그저 코드를 구현하기만 하면 되기 때문에 코드의 가독성이 좋으며 실행 속도가 빠르므로 계산이 많은 작업 등에 쓰인다. 

단점으로는 모듈화하기가 어렵고 유지 보수성이 떨어진다는 점이 있다.

예를 들어 자연수로 이뤄진 배열에서 최댓값을 찾으라고 한다면 다음과 같이 로직을 구성하는 것이다.

```js
const ret = [1, 2, 3, 4, 5, 11, 12]
let a = 0
for(let i = 0; i < ret.length; i++){
    a = Math.max(ret[i], a)
} 
console.log(a) // 12 
```
## 결론
어떤 패러다임이 가장 좋다라고 말할 수는 없고, 비즈니스 로직이나 서비스의 특징을 고려해서 패러다임을 정하는 것이 좋다. 하나의 패러다임 고집하기 보다는, 여러 패러다임을 조합해서 상황과 맥락에 따라 패러다임 간의 장점만 취해 개발하는 것이 제일 좋다.