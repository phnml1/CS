# 옵저버 패턴과 프록시 패턴
## 옵저버 패턴
`주체`가 어떤 `객체`의 상태 변화를 관찰하다가 상태 변화가 있을 때 마다 메서드 등을 통해 옵저버 목록에 있는 `옵저버들에게 변화를 알려주는` 디자인 패턴이다.

여기서 주체란 상태 변화를 보고 있는 관찰자이며, 옵저버들이란 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 '추가 변화 사항'이 생기는 객체들을 의미한다.

주체와 객체를 따로 두지 않고 상태가 변경되는 객체를 기반으로 구축하기도 한다.

ex)
- 트위터에서 주체를 팔로우 했다면 주체가 포스팅을 올릴 시 알림이 팔로워에게 가는 것
- MVC패턴에서도 주체라 볼 수 있는 모델에서 변경사항이 생길 시 뷰에 알려주고 이를 기반으로 컨트롤러가 작동하는 것

### 자바스크립트에서의 옵서버 패턴
자바스크립트에서의 옵서버 패턴은 `프록시 객체`를 통해 구현할 수 있다.
###  프록시 객체
어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체를 뜻하며, 두 개의 매개변수를 가진다.

- target: 프록시할 대상
- handler: 프록시 객체의 target 동작을 가로채서 정의할 동작을 정한 함수
 
```js
const handler = {
	get: function(target, name) {
		return name === 'name' ? `${target.a} ${target.b}`: target[name]
	}
}
const p = new Proxy({a: 'LEE', b'IS SHAKO JANGIN'}, handler);
console.log(p.name); // LEE IS SHAKO JANGIN;
```
new Proxy로 선언한 객체의 a와 b속성에 특정 문자열을 담아서 handler에서 "name이라는 속성에 접근 할 때 a와 b라는 것을 합쳐서 문자열을 만들어라"를 구현. p라는 변수에 name이라는 속성을 선언하지 않았는데도 p.name으로 name속성에 접근 하려고 할 때 그부분을 가로채 문자열을 만들어 반환한다.

### 프록시 객체를 이용한 옵저버 패턴
```js
function createReactiveObject(target, callback) { 
    const proxy = new Proxy(target, {
        set(obj, prop, value){
            if(value !== obj[prop]){
                const prev = obj[prop]
                obj[prop] = value 
                callback(`${prop}가 [${prev}] >> [${value}] 로 변경되었습니다`)
            }
            return true
        }
    })
    return proxy 
} 
const a = {
    "형규" : "솔로"
} 
const b = createReactiveObject(a, console.log)
b.형규 = "솔로"
b.형규 = "커플"
// 형규가 [솔로] >> [커플] 로 변경되었습니다
```
프록시 객체의 get 함수는 속성과 함수에 대한 접근을 가로채며, has()는 in 연산자의 사용을 가로채고, set()함수는 속성에 대한 접근을 가로챈다. set() 함수를 통해 속성에 대한 접근을 `가로채서` 형규라는 속성이 솔로에서 커플이 되는 것을 `감시`.

프록시 객체는 사실 디자인 패턴 중 하나인 프록시 패턴이 녹아들어 있는 객체이다.

## 프록시 패턴
대상 객체에 접근하기 전 그 `접근에 대한 흐름을 가로채` 객체 앞단의 인터페이스 역할을 하는 디자인 패턴이다.

프록시(Proxy)를 번역하면 `대리자, 대변인`의 의미를 갖고 있다. 대리자, 대변인은 누군가를 대신해서 그 역할을 수행하는 존재이다. 이는 프로그램에도 똑같이 적용된다. 즉, 프록시에게 어떤 일을 대신 시키는 것이다.

어떤 객체를 사용하고자 할때, 객체를 직접적으로 참조하는 것이 아닌 해당 객체를 대항하는 객체를 통해 대상 객체에 접근하는 방식을 사용하면 해당 객체가 메모리에 존재하지 않아도 기본적인 정보를 참조하거나 설정할 수 있고, 실제 객체의 기능이 필요한 시점까지 객체의 생성을 미룰 수 있다.

ex) 유튜브 썸네일에서 제목만 보여주다가, 프리뷰를 보여주는 일은 실제 클래스 호출

이를 통해 객체의 속성 ,변환 등을 보완하며 데이터 검증, 캐싱, 로깅에 사용한다.


```
프록시 서버에서의 캐싱:
캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해 다시 저 멀리 있는 원격 서버에 요청하지 않고 캐시안에 있는 데이터를 활용하는 것이다. 이를 통해 불필요하게 외부와 연결하지 않아서 트래픽을 줄일 수 있는 장점
``` 
### 프록시 서버
프록시 서버는 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템 혹은 응용프로그램

#### 프록시 서버로 쓰는 nginx
Node.js의 버퍼 오버플로우 취약점을 예방하기 위해 nginx를 앞단에 둔다.
``` 
버퍼 오버플로우: 버퍼는 데이터가 저장되는 메모리 공간으로 메모리 공간을 벗어나는 경우를 뜻한다.
```
#### 프록시 서버로 쓰는 CloudFlare
CloudFlare를 웹 서버 앞단의 프록시 서버로 쓰기 때문에, DDOS 공격 방어(CloudFlare는 의심스러운 트래픽, 특히 사용자가 접속하는 것이 아닌 트래픽을 자동 차단), 손쉬운 HTTPS 구축이 가능하다. 

```
CDN: 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크
```

#### CORS와 프론트엔드의 프록시 서버
`CORS`는 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘이다.
```
오리진
프로토콜과 호스트이름,포트의 조합을 말한다. https://kundol.com:12010/test라는 주소에서 오리진은 https://kundol.com:12010을 뜻함
```
프론트 엔드 개발 시 백엔드 서버와 통신할 때 CORS에러를 마주치는데 이를 해결하기 위해 프론트엔드에서 프록시 서버를 만들기도한다. 

